# Pi Pico ----------> Maestro
import time
from machine import Pin, SPI
from nrf24l01 import NRF24L01

# Configurar pines SPI utilizando SPI(0)
spi = SPI(0, baudrate=5000000, polarity=0, phase=0, sck=Pin(18), mosi=Pin(19), miso=Pin(20))
csn = Pin(16, mode=Pin.OUT, value=1)
ce = Pin(17, mode=Pin.OUT, value=0)

# Verifica que el módulo NRF24L01 esté conectado correctamente
try:
    nrf = NRF24L01(spi, csn, ce, payload_size=32)
    print("NRF24L01 inicializado correctamente")
except OSError as e:
    print("Error al inicializar el NRF24L01: ", e)
    raise SystemExit

# Configurar dirección de los nodos
pipes = [b'\xe1\xf0\xf0\xf0\xf0', b'\xd2\xf0\xf0\xf0\xf0']

nrf.open_tx_pipe(pipes[0])
nrf.open_rx_pipe(1, pipes[1])
nrf.start_listening()

def send_message(message):
    nrf.stop_listening()
    try:
        nrf.send(message)
    except OSError:
        print("No envío")
    nrf.start_listening()
    
# ! Altimetro
from machine import I2C, Pin
import math, utime, time
# Funciones
fahrenheit = lambda temp:1.8*temp + 32

def lecture(address, direcc):
    h = i2c.readfrom_mem(address, direcc, 1)[0]
    l = i2c.readfrom_mem(address, direcc+1, 1)[0]
    value = h << 8 | l
    if value >= 0x8000: value = - ((65535 - value) + 1)
    return value

def temperatura(ac5, ac6, mc, md):
    # Uncompeseted
    i2c.writeto_mem(address, 0xF4, b'\x2E')
    utime.sleep_ms(5)
    uT = lecture(address, 0xF6)
    x1 = (uT-ac6)*(ac5/pow(2, 15))
    x2 = (mc<<11)/int(x1+md)
    # Fixed
    b5 = x1 + x2
    temp = int(b5 + 8)>>4
    temp = temp/10.0
    return b5, temp

def presion(b2, b5, ac2, ac3, ac4, address):
    oss = 3
    osd = 26
    # Uncompeseted pressure
    i2c.writeto_mem(address, 0xF4,  b'\x34' + b'\oss<<6')
    utime.sleep_ms(osd)
    h = i2c.readfrom_mem(address, 0xF6, 1)[0]
    hl = i2c.readfrom_mem(address, 0xF7, 1)[0]
    l = i2c.readfrom_mem(address, 0xF8, 1)[0]
    uP = ((h<<16)|(hl<<8)|l)>>(8-oss)
    # Fixed
    b6 = b5 - 4000
    x1 = (b2*(b6*b6/pow(2, 12)))/pow(2, 11)
    x2 = (ac2*b6)/pow(2, 11)
    x3 = x1 + x2
    b3 = ((int(ac1*4 + x3)<<oss)+2)/4
    x1 = int(ac3*b6)>>13
    x2 = (b1*((b6*b6)/pow(2, 12)))/pow(2, 16)
    x3 = (x1+x2+2)/pow(2, 2)
    b4 = int(-ac4*(x3+32768))>>15 # Signo negativo en ac4
    b7 = int(uP-b3)*(50000>>oss)
    if b7 < 0x80000000:
        p = (b7*2)/b4
    else:
        p = (b7/b4)*2
    x1 = (int(p)>>8)*(int(p)>>8)
    x1 = (x1*3038)/pow(2, 16)
    x2 = (-7357*p)/pow(2, 16)
    p = p = p + (x1 + x2 + 3791) / 16
    return p/100

i2c = I2C(0,sda = Pin(0), scl = Pin(1), freq = 400000)
# Configuración modulo
address = 0x77
# Read calibration data 
ac1 = lecture(address, 0xAA)
ac2 = lecture(address, 0xAC)
ac3 = lecture(address, 0xAE)
ac4 = lecture(address, 0xB0) # ----------> Genera errores
ac5 = lecture(address, 0xB2)
ac6 = lecture(address, 0xB4)
b1  = lecture(address, 0xB6)
b2  = lecture(address, 0xB8)
mb  = lecture(address, 0xBA)
mc  = lecture(address, 0xBC)
md  = lecture(address, 0xBE)

while True:
    # Read temperatura value
    b5, t = temperatura(ac5, ac6, mc, md)
    # Read pressure value
    p = presion(b2, b5, ac2, ac3, ac4, address)-90 # Valor raro
    # Calculating absolute altitude
    a = 44330.08*(1-pow(p/1013.25, 0.190223))
    # Temperatura(C°), presion(mbar), altitud(m)
    mess = str(t) + ',' + str(p) + ',' + str(a) + '\n'
    send_message(mess)
    time.sleep(.1)
